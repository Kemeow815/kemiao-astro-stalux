---
import { getCollection } from 'astro:content';
import Head from '../../components/Head.vue';
import Header from '../../components/Header.astro';
import Footer from '../../components/Footer.vue';
import { config_site } from '../../utils/config-adapter';
import '../../../src/styles/global.styl';
import { processFrontmatter } from '../../utils/process-frontmatter';
// 获取文章集合
const allPosts = await getCollection('posts');
const processedPosts = await Promise.all(allPosts.map(post => processFrontmatter(post)));

// 提取并组织所有分类，构建三级嵌套结构
function extractNestedCategories(posts: any[]) {
  const categoryTree: Record<string, CategoryNode> = {};

  // 生成分类的URL路径，保持与Categories.astro组件一致的逻辑
  function generateCategoryPath(categoryName: any, parentPath = '') {
    return parentPath ? `${parentPath}/${categoryName}` : categoryName;
  }

  // 定义分类节点的接口
  interface CategoryNode {
    name: string;
    path: string;
    count: number; // 属于该分类的文章数量
    children: Record<string, CategoryNode>;
    posts: Array<{ slug: string; title: string }>; // 存储该分类直接关联的文章
  }

  // 定义分类树类型
  type CategoryTree = Record<string, CategoryNode>;

  // 初始化所有分类节点
  function initializeCategories(posts: any[]) {
    // 递归收集所有分类路径并创建节点
    function collectCategoryPaths(categories: any[], parentPath = '', tree: CategoryTree = categoryTree) {
      if (!categories || !Array.isArray(categories)) return;
      
      categories.forEach(category => {
        // 处理字符串格式的分类
        if (typeof category === 'string') {
          const catName = category;
          const currentPath = parentPath ? `${parentPath}/${catName}` : catName;
          
          if (!tree[catName]) {
            tree[catName] = {
              name: catName,
              path: currentPath,
              count: 0,
              children: {},
              posts: []
            };
          }
          return;
        }

        // 处理有name属性的对象格式
        if (category && typeof category === 'object' && category.name) {
          const catName = category.name;
          const currentPath = parentPath ? `${parentPath}/${catName}` : catName;
          
          if (!tree[catName]) {
            tree[catName] = {
              name: catName,
              path: currentPath,
              count: 0,
              children: {},
              posts: []
            };
          }
          
          // 递归处理子分类
          if (category.subcategories && Array.isArray(category.subcategories)) {
            collectCategoryPaths(category.subcategories, currentPath, tree[catName].children);
          }
          return;
        }
        
        // 处理key-array格式 {'category': [subcategories]}
        if (category && typeof category === 'object') {
          const keys = Object.keys(category);
          if (keys.length > 0) {
            const catName = keys[0];
            const currentPath = parentPath ? `${parentPath}/${catName}` : catName;
            
            if (!tree[catName]) {
              tree[catName] = {
                name: catName,
                path: currentPath,
                count: 0,
                children: {},
                posts: []
              };
            }
            
            // 递归处理子分类
            const subCategories = category[catName];
            if (Array.isArray(subCategories)) {
              collectCategoryPaths(subCategories, currentPath, tree[catName].children);
            }
          }
        }
      });
    }

    // 初始化目录树结构
    posts.forEach(post => {
      if (post.data.categories) {
        const categories = Array.isArray(post.data.categories) 
          ? post.data.categories 
          : [post.data.categories];
        collectCategoryPaths(categories);
      }
    });
  }

  // 判断文章是否属于特定分类路径
  function isPostInCategory(post: { data: { categories: any; }; }, targetPath: string) {
    if (!post.data.categories || !Array.isArray(post.data.categories)) return false;
    
    // 构建文章分类的所有路径
    const postCategoryPaths: string[] = [];
    
    function buildPostCategoryPaths(categories: any[], parentPath = '') {
      categories.forEach((category: { [x: string]: any; name?: any; subcategories?: any; }) => {
        if (typeof category === 'string') {
          postCategoryPaths.push(parentPath ? `${parentPath}/${category}` : category);
        } else if (category && typeof category === 'object' && category.name) {
          const catName = category.name;
          const currentPath = parentPath ? `${parentPath}/${catName}` : catName;
          postCategoryPaths.push(currentPath);
          
          if (category.subcategories && Array.isArray(category.subcategories)) {
            buildPostCategoryPaths(category.subcategories, currentPath);
          }
        } else if (category && typeof category === 'object') {
          const keys = Object.keys(category);
          if (keys.length > 0) {
            const catName = keys[0];
            const currentPath = parentPath ? `${parentPath}/${catName}` : catName;
            postCategoryPaths.push(currentPath);
            
            const subCategories = category[catName];
            if (Array.isArray(subCategories)) {
              buildPostCategoryPaths(subCategories, currentPath);
            }
          }
        }
      });
    }
    
    buildPostCategoryPaths(post.data.categories);
    
    // 检查文章分类路径是否包含目标路径
    return postCategoryPaths.some(path => path === targetPath);
  }

  // 计算每个分类的文章数量
  function calculateCategoryCounts() {
    // 递归处理所有分类节点
    function processNode(node: CategoryNode, nodePath: string) {
      // 计算直接属于该分类的文章数量
      const postsInCategory = posts.filter(post => isPostInCategory(post, nodePath));
      node.count = postsInCategory.length;
      
      // 为文章添加元数据
      node.posts = postsInCategory.map(post => ({
        slug: post.slug,
        title: post.data.title || post.slug
      }));
      
      // 递归处理子分类
      Object.entries(node.children).forEach(([childName, childNode]) => {
        processNode(childNode, childNode.path);
      });
    }
    
    // 处理顶级分类
    Object.entries(categoryTree).forEach(([catName, node]) => {
      processNode(node, node.path);
    });
  }
  
  // 初始化分类树结构
  initializeCategories(posts);
  
  // 计算每个分类的文章数量
  calculateCategoryCounts();
  
  return categoryTree;
}

// 获取所有分类并按文章数量排序
const categoryTree = extractNestedCategories(processedPosts);

// 排序函数，将分类按文章数量降序排列
function sortCategoriesByCount(categories: ArrayLike<unknown> | { [s: string]: unknown; }) {
  interface CategoryNode {
    sortedChildren: CategoryNode[];
    name: string;
    path: string;
    count: number;
    children: Record<string, CategoryNode>;
    posts: Array<{ slug: string; title: string }>;
  }
  return Object.entries(categories)
    .sort(([, catA]: [string, any], [, catB]: [string, any]) => catB.count - catA.count)
    .map((value: [string, unknown]) => {
      const category = value[1] as CategoryNode;
      if (Object.keys(category.children).length > 0) {
        category.sortedChildren = sortCategoriesByCount(category.children);
      }
      return category;
    });
}

const sortedCategories = sortCategoriesByCount(categoryTree);

// 页面标题
const pageTitle = '文章分类 | ' + config_site.title;
import '../../styles/pages/categories/index.styl';
---

<!DOCTYPE html>
<html lang={config_site.lang}>
  <Head 
    title={pageTitle}
    description="所有文章分类列表，按主题分类索引"
    author={config_site.author}
    url={config_site.url + '/categories/'}
  >
    <!-- 使用新的 robots 插槽来替换默认的 robots meta 标签 -->
    <meta name="robots" content="noindex, nofollow" slot="robots" />
  </Head>
  <body>
    <script>
      import '../../scripts/background.ts';
    </script>
    <Header />
    <main class="categories-container">
      <div class="page-header">
        <h1 class="page-title">文章分类</h1>
        <p class="page-description">按主题分类浏览</p>
      </div>

      <!-- 主分类卡片网格 -->
      <div class="categories-grid">
        {sortedCategories.length > 0 ? (
          sortedCategories.map((category) => (
            <div class={`category-card level-1 ${category.sortedChildren?.length ? 'has-children' : ''}`}>
              <a href={`/categories/${category.path}`} class="category-header">
                <div class="category-icon">
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                  </svg>
                </div>
                <div class="category-content">
                  <h2 class="category-name">{category.name}</h2>
                  <div class="category-count">{category.posts.length} 篇文章</div>
                </div>
              </a>
              
              <!-- 二级子分类 -->
              {category.sortedChildren?.length > 0 && (
                <div class="subcategories level-2">
                  {category.sortedChildren.map((subCategory: { sortedChildren: any[]; path: any; name: unknown; posts: any[]; }) => (
                    <div class={`subcategory-card ${subCategory.sortedChildren?.length ? 'has-children' : ''}`}>
                      <a href={`/categories/${subCategory.path}`} class="subcategory-header">
                        <h3 class="subcategory-name">{subCategory.name}</h3>
                        <div class="subcategory-count">{subCategory.posts.length} 篇文章</div>
                      </a>
                      
                      <!-- 三级子分类 (伪平铺) -->
                      {subCategory.sortedChildren?.length > 0 && (
                        <div class="subcategories level-3">
                          {subCategory.sortedChildren.map((thirdLevelCategory: { path: any; name: unknown; posts: any[]; }) => (
                            <a href={`/categories/${thirdLevelCategory.path}`} class="third-level-category">
                              {thirdLevelCategory.name} 
                              <span class="third-level-count">({thirdLevelCategory.posts.length})</span>
                            </a>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          ))
        ) : (
          <div class="no-categories">暂无分类</div>
        )}
      </div>
    </main>
    <Footer />
  </body>
</html>
