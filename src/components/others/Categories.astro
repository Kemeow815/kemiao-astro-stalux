---
// 分类组件
const { categories = [] as any[] } = Astro.props;

// 为分类生成扁平化路径和显示文本
function generateCategoryPaths(categories: any[]) {
  const result: { path: string; display: string; level: number }[] = [];
  
  // 处理单个分类项，支持多种格式
  function traverse(category: any, parentPath = '', level = 0) {
    // 处理字符串格式的分类
    if (typeof category === 'string') {
      const currentPath = parentPath ? `${parentPath}/${category}` : category;
      result.push({
        path: `/categories/${currentPath}`,
        display: category,
        level: level
      });
      return;
    }
    
    // 处理对象格式的分类
    if (category && typeof category === 'object') {
      // 有标签的格式: { name: 'category', subcategories: [...] }
      if (category.name) {
        const currentPath = parentPath ? `${parentPath}/${category.name}` : category.name;
        result.push({
          path: `/categories/${currentPath}`,
          display: category.name,
          level: level
        });
        
        // 递归处理子分类
        if (category.subcategories && Array.isArray(category.subcategories)) {
          category.subcategories.forEach((child: any) => {
            traverse(child, currentPath, level + 1);
          });
        }
      } 
      // 无标签的格式: { 'category': [...subcategories] }
      else {
        // 获取第一个键作为分类名
        const keys = Object.keys(category);
        if (keys.length > 0) {
          const categoryName = keys[0];
          const subCategories = category[categoryName];
          
          // 添加当前分类
          const currentPath = parentPath ? `${parentPath}/${categoryName}` : categoryName;
          result.push({
            path: `/categories/${currentPath}`,
            display: categoryName,
            level: level
          });
          
          // 递归处理子分类
          if (Array.isArray(subCategories)) {
            subCategories.forEach((child: any) => {
              traverse(child, currentPath, level + 1);
            });
          }
        }
      }
    }
    // 处理缩进式YAML格式的分类结构
    // 以前缀'-'或者缩进形式表示子分类的情况
    else if (Array.isArray(category) && category.length > 0) {
      // 这种情况下，数组内可能是带有子分类的嵌套数组
      category.forEach((item, index) => {
        if (index === 0 && typeof item === 'string') {
          // 第一个元素作为分类名
          const currentPath = parentPath ? `${parentPath}/${item}` : item;
          result.push({
            path: `/categories/${currentPath}`,
            display: item,
            level: level
          });
          
          // 如果还有其他元素，视为子分类继续处理
          if (category.length > 1) {
            for (let i = 1; i < category.length; i++) {
              traverse(category[i], currentPath, level + 1);
            }
          }
        } else {
          // 当数组内元素不是字符串时，作为独立项处理
          traverse(item, parentPath, level);
        }
      });
    }
  }
  
  // 预处理 - 支持缩进式YAML结构
  function preprocessCategories(cats: any[]) {
    const processed: any[] = [];
    
    // 处理每个顶级分类
    cats.forEach(cat => {
      // 如果是字符串，直接添加
      if (typeof cat === 'string') {
        processed.push(cat);
      } 
      // 如果是数组，说明这是带有子分类的结构
      else if (Array.isArray(cat)) {
        processed.push(cat);
      }
      // 处理对象格式
      else if (typeof cat === 'object') {
        if (cat.name || Object.keys(cat).length > 0) {
          processed.push(cat);
        }
      }
    });
    
    return processed;
  }
  
  if (Array.isArray(categories)) {
    // 预处理分类数据以支持更多的格式
    const processedCategories = preprocessCategories(categories);
    processedCategories.forEach(category => traverse(category));
  }
  
  return result;
}

// 辅助函数：尝试解析可能是字符串表示的数组
function parseNestedCategories(categories: any[]): any[] {
  // 已经是数组则直接返回
  if (Array.isArray(categories)) {
    return categories.map(item => {
      // 检查是否是字符串，可能代表一个类别
      if (typeof item === 'string') {
        return item;
      }
      // 递归处理可能的嵌套结构
      else if (Array.isArray(item)) {
        return parseNestedCategories(item);
      }
      // 返回原始对象
      return item;
    });
  }
  return [];
}

// 尝试解析可能存在的特殊格式
const parsedCategories = parseNestedCategories(categories);
const flattenedCategories = Array.isArray(parsedCategories) ? generateCategoryPaths(parsedCategories) : [];

// 为每个分类级别生成不同的缩进标记
function getIndentMark(level: number): string {
  if (level === 0) return '';
  return '  '.repeat(level);
}

// 简化分类处理，不再需要isLast属性
const organizedCategories = flattenedCategories;
---

<!-- 文章分类部分 -->
<div class="sidebar-section categories">
  <div class="section-header">
    <h3>文章分类</h3>
    <button id="categories-toggle" class="section-toggle" aria-label="折叠分类">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="18" height="18">
        <path fill="currentColor" d="M7 10l5 5 5-5z"></path>
      </svg>
    </button>
  </div>
  <div id="categories-content" class="section-content">
    <div class="category-tree">
      {organizedCategories && organizedCategories.length > 0 ? (
        organizedCategories.map((cat) => (
          <a href={cat.path} class={`category level-${cat.level}`}>
            <span class="indent">{getIndentMark(cat.level)}</span>
            <span class="category-name">{cat.display}</span>
          </a>
        ))
      ) : (
        <div class="no-categories">暂无分类</div>
      )}
    </div>
  </div>
</div>

<style>
  .sidebar-section {
    background-color: rgba(0, 0, 0, 0.192);
    border-radius: 8px;
    padding: 1rem;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.753);
    background-color: rgba(0, 0, 0, 0.1);
    margin-bottom: 1.5rem;
  }
  
  .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.8rem;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    padding-bottom: 0.5rem;
  }
  
  .sidebar-section h3 {
    margin: 0;
    font-size: 1.2rem;
    color: rgba(255, 255, 255, 0.9);
  }

  .section-toggle {
    background: none;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    cursor: pointer;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s ease;
  }

  .section-toggle:hover {
    color: rgba(255, 255, 255, 1);
  }
  
  .section-toggle.collapsed {
    transform: rotate(-90deg);
  }
  
  .section-content {
    max-height: 500px;
    overflow-y: auto;
    opacity: 1;
    transition: max-height 0.3s ease, opacity 0.3s ease;
    scrollbar-width: thin;
    scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
  }
  
  .section-content::-webkit-scrollbar {
    width: 6px;
  }
  
  .section-content::-webkit-scrollbar-track {
    background: transparent;
  }
  
  .section-content::-webkit-scrollbar-thumb {
    background-color: rgba(255, 255, 255, 0.3);
    border-radius: 3px;
  }
  
  .section-content.collapsed {
    max-height: 0;
    opacity: 0;
    overflow: hidden;
  }
  
  .category-tree {
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
    padding: 0.2rem;
  }
  
  .category {
    position: relative;
    display: flex;
    align-items: center;
    border-radius: 4px;
    padding: 0.25rem 0.4rem;
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.9);
    text-decoration: none;
    transition: all 0.2s ease;
    margin-bottom: 0.1rem;
    overflow: hidden;
  }

  .category .indent {
    color: rgba(255, 255, 255, 0.5);
    font-family: monospace;
    margin-right: 0.2rem;
    white-space: pre;
    letter-spacing: -0.5px;
  }
  
  .category .category-name {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    position: relative;
    z-index: 1;
  }

  /* 不同层级的颜色和样式 */
  .category.level-0 {
    font-weight: 600;
    border-left: 2px solid rgba(255, 168, 70, 0.7);
  }
  
  .category.level-1 {
    border-left: 2px solid rgba(114, 137, 218, 0.7);
  }
  
  .category.level-2 {
    border-left: 2px solid rgba(70, 200, 120, 0.7);
  }
  
  .category.level-3 {
    border-left: 2px solid rgba(220, 100, 150, 0.7);
  }
  
  /* 悬停效果 */
  .category:hover {
    background-color: rgba(255, 255, 255, 0.18);
    transform: translateX(2px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
  }

  .category:hover .indent {
    color: rgba(255, 255, 255, 0.8);
  }
  
  .category:hover::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, 
      rgba(255, 255, 255, 0) 0%, 
      rgba(255, 255, 255, 0.05) 50%,
      rgba(255, 255, 255, 0) 100%);
    z-index: 0;
    animation: shine 1s ease-in-out;
  }
  
  @keyframes shine {
    0% {
      transform: translateX(-100%);
    }
    100% {
      transform: translateX(100%);
    }
  }

  .no-categories {
    color: rgba(255, 255, 255, 0.6);
    font-style: italic;
    font-size: 0.9rem;
    padding: 0.5rem;
    text-align: center;
  }
</style>

<script>
  // 分类折叠/展开功能
  document.addEventListener('DOMContentLoaded', () => {
    const toggleBtn = document.getElementById('categories-toggle');
    const contentEl = document.getElementById('categories-content');
    
    if (toggleBtn && contentEl) {
      toggleBtn.addEventListener('click', () => {
        const isCollapsing = !contentEl.classList.contains('collapsed');
        
        if (isCollapsing) {
          // 快速折叠 (250ms)
          contentEl.style.transition = 'max-height 0.25s ease, opacity 0.25s ease';
        } else {
          // 缓慢展开 (600ms)
          contentEl.style.transition = 'max-height 0.6s ease, opacity 0.6s ease';
        }
        
        contentEl.classList.toggle('collapsed');
        toggleBtn.classList.toggle('collapsed');
      });
    }
  });
</script>