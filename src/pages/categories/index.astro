---
import { getCollection } from 'astro:content';
import Head from '../../components/Head.vue';
import Header from '../../components/Header.astro';
import Footer from '../../components/Footer.vue';
import { config_site } from '../../utils/config-adapter';
import '../../../src/styles/global.styl';
import { processFrontmatter } from '../../utils/process-frontmatter';
// 获取文章集合
const allPosts = await getCollection('posts');
const processedPosts = await Promise.all(allPosts.map(post => processFrontmatter(post)));

// 提取并组织所有分类，构建三级嵌套结构
function extractNestedCategories(posts: any[]) {
  const categoryTree: Record<string, CategoryNode> = {};

  // 生成分类的URL路径，保持与Categories.astro组件一致的逻辑
  function generateCategoryPath(categoryName: any, parentPath = '') {
    return parentPath ? `${parentPath}/${categoryName}` : categoryName;
  }

  // 定义分类节点的接口
  interface CategoryNode {
    name: string;
    path: string;
    count: number; // 属于该分类的文章数量
    children: Record<string, CategoryNode>;
    posts: Array<{ slug: string; title: string }>; // 存储该分类直接关联的文章
  }

  // 定义分类树类型
  type CategoryTree = Record<string, CategoryNode>;

  // 初始化所有分类节点
  function initializeCategories(posts: any[]) {
    // 递归收集所有分类路径并创建节点
    function collectCategoryPaths(categories: any[], parentPath = '', tree: CategoryTree = categoryTree) {
      if (!categories || !Array.isArray(categories)) return;
      
      categories.forEach(category => {
        // 处理字符串格式的分类
        if (typeof category === 'string') {
          const catName = category;
          const currentPath = parentPath ? `${parentPath}/${catName}` : catName;
          
          if (!tree[catName]) {
            tree[catName] = {
              name: catName,
              path: currentPath,
              count: 0,
              children: {},
              posts: []
            };
          }
          return;
        }

        // 处理有name属性的对象格式
        if (category && typeof category === 'object' && category.name) {
          const catName = category.name;
          const currentPath = parentPath ? `${parentPath}/${catName}` : catName;
          
          if (!tree[catName]) {
            tree[catName] = {
              name: catName,
              path: currentPath,
              count: 0,
              children: {},
              posts: []
            };
          }
          
          // 递归处理子分类
          if (category.subcategories && Array.isArray(category.subcategories)) {
            collectCategoryPaths(category.subcategories, currentPath, tree[catName].children);
          }
          return;
        }
        
        // 处理key-array格式 {'category': [subcategories]}
        if (category && typeof category === 'object') {
          const keys = Object.keys(category);
          if (keys.length > 0) {
            const catName = keys[0];
            const currentPath = parentPath ? `${parentPath}/${catName}` : catName;
            
            if (!tree[catName]) {
              tree[catName] = {
                name: catName,
                path: currentPath,
                count: 0,
                children: {},
                posts: []
              };
            }
            
            // 递归处理子分类
            const subCategories = category[catName];
            if (Array.isArray(subCategories)) {
              collectCategoryPaths(subCategories, currentPath, tree[catName].children);
            }
          }
        }
      });
    }

    // 初始化目录树结构
    posts.forEach(post => {
      if (post.data.categories) {
        const categories = Array.isArray(post.data.categories) 
          ? post.data.categories 
          : [post.data.categories];
        collectCategoryPaths(categories);
      }
    });
  }

  // 判断文章是否属于特定分类路径
  function isPostInCategory(post: { data: { categories: any; }; }, targetPath: string) {
    if (!post.data.categories || !Array.isArray(post.data.categories)) return false;
    
    // 构建文章分类的所有路径
    const postCategoryPaths: string[] = [];
    
    function buildPostCategoryPaths(categories: any[], parentPath = '') {
      categories.forEach((category: { [x: string]: any; name?: any; subcategories?: any; }) => {
        if (typeof category === 'string') {
          postCategoryPaths.push(parentPath ? `${parentPath}/${category}` : category);
        } else if (category && typeof category === 'object' && category.name) {
          const catName = category.name;
          const currentPath = parentPath ? `${parentPath}/${catName}` : catName;
          postCategoryPaths.push(currentPath);
          
          if (category.subcategories && Array.isArray(category.subcategories)) {
            buildPostCategoryPaths(category.subcategories, currentPath);
          }
        } else if (category && typeof category === 'object') {
          const keys = Object.keys(category);
          if (keys.length > 0) {
            const catName = keys[0];
            const currentPath = parentPath ? `${parentPath}/${catName}` : catName;
            postCategoryPaths.push(currentPath);
            
            const subCategories = category[catName];
            if (Array.isArray(subCategories)) {
              buildPostCategoryPaths(subCategories, currentPath);
            }
          }
        }
      });
    }
    
    buildPostCategoryPaths(post.data.categories);
    
    // 检查文章分类路径是否包含目标路径
    return postCategoryPaths.some(path => path === targetPath);
  }

  // 计算每个分类的文章数量
  function calculateCategoryCounts() {
    // 递归处理所有分类节点
    function processNode(node: CategoryNode, nodePath: string) {
      // 计算直接属于该分类的文章数量
      const postsInCategory = posts.filter(post => isPostInCategory(post, nodePath));
      node.count = postsInCategory.length;
      
      // 为文章添加元数据
      node.posts = postsInCategory.map(post => ({
        slug: post.slug,
        title: post.data.title || post.slug
      }));
      
      // 递归处理子分类
      Object.entries(node.children).forEach(([childName, childNode]) => {
        processNode(childNode, childNode.path);
      });
    }
    
    // 处理顶级分类
    Object.entries(categoryTree).forEach(([catName, node]) => {
      processNode(node, node.path);
    });
  }
  
  // 初始化分类树结构
  initializeCategories(posts);
  
  // 计算每个分类的文章数量
  calculateCategoryCounts();
  
  return categoryTree;
}

// 获取所有分类并按文章数量排序
const categoryTree = extractNestedCategories(processedPosts);

// 排序函数，将分类按文章数量降序排列
function sortCategoriesByCount(categories: ArrayLike<unknown> | { [s: string]: unknown; }) {
  interface CategoryNode {
    sortedChildren: CategoryNode[];
    name: string;
    path: string;
    count: number;
    children: Record<string, CategoryNode>;
    posts: Array<{ slug: string; title: string }>;
  }
  return Object.entries(categories)
    .sort(([, catA]: [string, any], [, catB]: [string, any]) => catB.count - catA.count)
    .map((value: [string, unknown]) => {
      const category = value[1] as CategoryNode;
      if (Object.keys(category.children).length > 0) {
        category.sortedChildren = sortCategoriesByCount(category.children);
      }
      return category;
    });
}

const sortedCategories = sortCategoriesByCount(categoryTree);

// 页面标题
const pageTitle = '文章分类 | ' + config_site.title;
---

<!DOCTYPE html>
<html lang={config_site.lang}>
  <Head 
    title={pageTitle}
    description="所有文章分类列表，按主题分类索引"
    author={config_site.author}
    url={config_site.url + '/categories/'}
  >
    <!-- 使用新的 robots 插槽来替换默认的 robots meta 标签 -->
    <meta name="robots" content="noindex, nofollow" slot="robots" />
  </Head>
  <body>
    <script>
      import '../../scripts/background.ts';
    </script>
    <Header />
    <main class="categories-container">
      <div class="page-header">
        <h1 class="page-title">文章分类</h1>
        <p class="page-description">按主题分类浏览</p>
      </div>

      <!-- 主分类卡片网格 -->
      <div class="categories-grid">
        {sortedCategories.length > 0 ? (
          sortedCategories.map((category) => (
            <div class={`category-card level-1 ${category.sortedChildren?.length ? 'has-children' : ''}`}>
              <a href={`/categories/${category.path}`} class="category-header">
                <div class="category-icon">
                  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
                  </svg>
                </div>
                <div class="category-content">
                  <h2 class="category-name">{category.name}</h2>
                  <div class="category-count">{category.posts.length} 篇文章</div>
                </div>
              </a>
              
              <!-- 二级子分类 -->
              {category.sortedChildren?.length > 0 && (
                <div class="subcategories level-2">
                  {category.sortedChildren.map((subCategory: { sortedChildren: any[]; path: any; name: unknown; posts: any[]; }) => (
                    <div class={`subcategory-card ${subCategory.sortedChildren?.length ? 'has-children' : ''}`}>
                      <a href={`/categories/${subCategory.path}`} class="subcategory-header">
                        <h3 class="subcategory-name">{subCategory.name}</h3>
                        <div class="subcategory-count">{subCategory.posts.length} 篇文章</div>
                      </a>
                      
                      <!-- 三级子分类 (伪平铺) -->
                      {subCategory.sortedChildren?.length > 0 && (
                        <div class="subcategories level-3">
                          {subCategory.sortedChildren.map((thirdLevelCategory: { path: any; name: unknown; posts: any[]; }) => (
                            <a href={`/categories/${thirdLevelCategory.path}`} class="third-level-category">
                              {thirdLevelCategory.name} 
                              <span class="third-level-count">({thirdLevelCategory.posts.length})</span>
                            </a>
                          ))}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              )}
            </div>
          ))
        ) : (
          <div class="no-categories">暂无分类</div>
        )}
      </div>
    </main>
    <Footer />
  </body>
</html>

<style lang="stylus">
.categories-container {
  max-width: 1200px
  margin: 0 auto
  padding: 2rem 1rem
  min-height: calc(100vh - 200px)
}

.page-header {
  text-align: center
  margin-bottom: 3rem
  
  .page-title {
    font-size: 2.5rem
    margin-bottom: 1rem
    background: linear-gradient(90deg, rgba(255,255,255,0.9), rgba(255,255,255,0.7))
    -webkit-background-clip: text
    -webkit-text-fill-color: transparent
    background-clip: text
  }
  
  .page-description {
    font-size: 1.1rem
    color: rgba(255, 255, 255, 0.8)
    max-width: 600px
    margin: 0 auto
  }
}

.categories-grid {
  display: grid
  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr))
  gap: 1.8rem
  padding: 1rem
  max-width: 1200px
  margin: 0 auto
}

// 一级分类卡片
.category-card {
  position: relative
  display: flex
  flex-direction: column
  padding: 1.5rem
  background-color: rgba(255, 255, 255, 0.05)
  border-radius: 0.8rem
  border: 1px solid rgba(255, 255, 255, 0.1)
  color: #ffffff
  transition: all 0.3s ease
  overflow: hidden
  
  &.has-children {
    padding-bottom: 2rem
  }
  
  &::before {
    content: ""
    position: absolute
    top: 0
    left: 0
    width: 100%
    height: 100%
    background: linear-gradient(120deg, rgba(255,255,255,0), rgba(255,255,255,0.05), rgba(255,255,255,0))
    transform: translateX(-100%)
    transition: transform 0.6s
    z-index: 1
  }
  
  &:hover {
    transform: translateY(-3px)
    background-color: rgba(255, 255, 255, 0.08)
    border-color: rgba(1, 162, 190, 0.5)
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3)
    
    &::before {
      transform: translateX(100%)
    }
    
    .category-icon {
      transform: rotate(-15deg) translateY(-3px)
      background: rgba(1, 162, 190, 0.3)
      color: rgba(255, 255, 255, 0.9)
      box-shadow: 0 3px 8px rgba(1, 162, 190, 0.3)
      opacity: 1
    }
  }
}

.category-header {
  display: flex
  text-decoration: none
  color: #ffffff
  position: relative
  padding-bottom: 0.5rem
  border-bottom: 1px dashed rgba(255, 255, 255, 0.1)
  margin-bottom: 1rem
  justify-content: space-between
}

.category-icon {
  position: absolute
  top: 10px
  right: 10px
  width: 28px
  height: 28px
  color: rgba(255, 255, 255, 0.5)
  transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275)
  z-index: 2
  transform-origin: center center
  background: rgba(0, 0, 0, 0.15)
  padding: 5px
  border-radius: 6px
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1)
  opacity: 0.8
  
  svg {
    width: 100%
    height: 100%
  }
}

.category-content {
  flex: 1
  padding-right: 30px
}

.category-name {
  font-size: 1.5rem
  margin: 0 0 0.5rem 0
  position: relative
  z-index: 2
  background: linear-gradient(45deg, #fff, #fff)
  -webkit-background-clip: text
  -webkit-text-fill-color: transparent
  background-clip: text
}

.category-count {
  font-size: 0.9rem
  color: #ffffff
  position: relative
  z-index: 2
}

// 二级分类
.subcategories.level-2 {
  margin-top: 0.5rem
  position: relative
}

.subcategory-card {
  margin-bottom: 1rem
  padding: 0.5rem 0.8rem
  background: rgba(255, 255, 255, 0.03)
  border-radius: 0.5rem
  border-left: 2px solid rgba(1, 162, 190, 0.4)
  transition: all 0.3s ease
  
  &:hover {
    background: rgba(255, 255, 255, 0.06)
    border-left-color: rgba(1, 162, 190, 0.8)
  }
  
  &.has-children {
    padding-bottom: 1rem
  }
}

.subcategory-header {
  text-decoration: none
  color: #ffffff
  display: flex
  justify-content: space-between
  align-items: center
  padding-bottom: 0.3rem
  border-bottom: 1px dotted rgba(255, 255, 255, 0.1)
}

.subcategory-name {
  font-size: 1.2rem
  margin: 0
  color: #ffffff
}

.subcategory-count {
  font-size: 0.85rem
  color: #ffffff
}

// 三级分类（伪平铺）
.subcategories.level-3 {
  margin-top: 0.5rem
  padding: 0.5rem
  display: flex
  flex-wrap: wrap
  gap: 0.5rem
  background: rgba(0, 0, 0, 0.2)
  border-radius: 0.3rem
}

.third-level-category {
  text-decoration: none
  color: #ffffff
  font-size: 0.9rem
  padding: 0.3rem 0.6rem
  background: rgba(255, 255, 255, 0.05)
  border-radius: 0.3rem
  transition: all 0.2s ease
  
  &:hover {
    background: rgba(255, 255, 255, 0.1)
    color: #ffffff
  }
}

.third-level-count {
  font-size: 0.8rem
  color: #ffffff
  margin-left: 0.3rem
}

.no-categories {
  text-align: center
  grid-column: 1 / -1
  padding: 3rem 1rem
  color: rgba(255, 255, 255, 0.7)
  font-size: 1.2rem
  background-color: rgba(0, 0, 0, 0.1)
  border-radius: 0.5rem
}

@media (max-width: 768px) {
  .page-header {
    margin-bottom: 2rem
    
    .page-title {
      font-size: 2rem
    }
    
    .page-description {
      font-size: 1rem
    }
  }
  
  .categories-grid {
    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr))
    gap: 1rem
  }
  
  .category-card {
    padding: 1.2rem
  }
  
  .category-name {
    font-size: 1.3rem
  }
  
  .subcategories.level-3 {
    flex-direction: column
    gap: 0.3rem
  }
}

@media (max-width: 480px) {
  .categories-container {
    padding: 1.5rem 0.8rem
  }
  
  .page-header {
    .page-title {
      font-size: 1.8rem
    }
  }
  
  .categories-grid {
    grid-template-columns: 1fr
    padding: 0.5rem
  }
  
  .category-name {
    font-size: 1.2rem
  }
  
  .subcategory-name {
    font-size: 1.1rem
  }
}
</style>